#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod bytable {
    use {
        crate::{
            utils::{grow_be_int, grow_be_uint, grow_le_int, grow_le_uint},
            Uint,
        },
        bnum::types::{I256, I512, U256, U512},
    };
    /// Describes a number that can be convert to and from raw binary representations.
    pub trait Bytable<const S: usize>: Sized {
        const BYTE_LEN: usize = S;
        fn from_be_bytes(data: [u8; S]) -> Self;
        fn from_le_bytes(data: [u8; S]) -> Self;
        fn to_be_bytes(self) -> [u8; S];
        fn to_le_bytes(self) -> [u8; S];
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; S];
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; S];
        fn from_be_bytes_growing<const INPUT_SIZE: usize>(
            data: [u8; INPUT_SIZE],
        ) -> Self {
            Self::from_be_bytes(Self::grow_be_bytes(data))
        }
        fn from_le_bytes_growing<const INPUT_SIZE: usize>(
            data: [u8; INPUT_SIZE],
        ) -> Self {
            Self::from_le_bytes(Self::grow_le_bytes(data))
        }
    }
    impl<U, const S: usize> Bytable<S> for Uint<U>
    where
        U: Bytable<S>,
    {
        fn from_be_bytes(data: [u8; S]) -> Self {
            Self(U::from_be_bytes(data))
        }
        fn from_le_bytes(data: [u8; S]) -> Self {
            Self(U::from_le_bytes(data))
        }
        fn to_be_bytes(self) -> [u8; S] {
            self.0.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; S] {
            self.0.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; S] {
            U::grow_be_bytes(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; S] {
            U::grow_le_bytes(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<1> for u8 {
        fn from_be_bytes(data: [u8; 1]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 1]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 1] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 1] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 1] {
            grow_be_uint::<INPUT_SIZE, 1>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 1] {
            grow_le_uint::<INPUT_SIZE, 1>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<2> for u16 {
        fn from_be_bytes(data: [u8; 2]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 2]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 2] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 2] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 2] {
            grow_be_uint::<INPUT_SIZE, 2>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 2] {
            grow_le_uint::<INPUT_SIZE, 2>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<4> for u32 {
        fn from_be_bytes(data: [u8; 4]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 4]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 4] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 4] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 4] {
            grow_be_uint::<INPUT_SIZE, 4>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 4] {
            grow_le_uint::<INPUT_SIZE, 4>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<8> for u64 {
        fn from_be_bytes(data: [u8; 8]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 8]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 8] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 8] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 8] {
            grow_be_uint::<INPUT_SIZE, 8>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 8] {
            grow_le_uint::<INPUT_SIZE, 8>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<16> for u128 {
        fn from_be_bytes(data: [u8; 16]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 16]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 16] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 16] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 16] {
            grow_be_uint::<INPUT_SIZE, 16>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 16] {
            grow_le_uint::<INPUT_SIZE, 16>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<1> for i8 {
        fn from_be_bytes(data: [u8; 1]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 1]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 1] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 1] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 1] {
            grow_be_int::<INPUT_SIZE, 1>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 1] {
            grow_le_int::<INPUT_SIZE, 1>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<2> for i16 {
        fn from_be_bytes(data: [u8; 2]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 2]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 2] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 2] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 2] {
            grow_be_int::<INPUT_SIZE, 2>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 2] {
            grow_le_int::<INPUT_SIZE, 2>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<4> for i32 {
        fn from_be_bytes(data: [u8; 4]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 4]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 4] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 4] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 4] {
            grow_be_int::<INPUT_SIZE, 4>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 4] {
            grow_le_int::<INPUT_SIZE, 4>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<8> for i64 {
        fn from_be_bytes(data: [u8; 8]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 8]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 8] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 8] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 8] {
            grow_be_int::<INPUT_SIZE, 8>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 8] {
            grow_le_int::<INPUT_SIZE, 8>(data)
        }
    }
    #[deny(unconditional_recursion)]
    impl Bytable<16> for i128 {
        fn from_be_bytes(data: [u8; 16]) -> Self {
            Self::from_be_bytes(data)
        }
        fn from_le_bytes(data: [u8; 16]) -> Self {
            Self::from_le_bytes(data)
        }
        fn to_be_bytes(self) -> [u8; 16] {
            self.to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 16] {
            self.to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 16] {
            grow_be_int::<INPUT_SIZE, 16>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 16] {
            grow_le_int::<INPUT_SIZE, 16>(data)
        }
    }
    impl Bytable<32> for U256 {
        fn from_be_bytes(bytes: [u8; 32]) -> Self {
            Self::from_be_slice(&bytes).unwrap()
        }
        fn from_le_bytes(bytes: [u8; 32]) -> Self {
            Self::from_le_slice(&bytes).unwrap()
        }
        fn to_be_bytes(self) -> [u8; 32] {
            let words = self.digits();
            let mut bytes = [[0u8; 8]; 32 / 8];
            for i in 0..32 / 8 {
                bytes[i] = words[32 / 8 - i - 1].to_be_bytes();
            }
            unsafe { std::mem::transmute(bytes) }
        }
        fn to_le_bytes(self) -> [u8; 32] {
            let words = self.digits();
            let mut bytes = [[0u8; 8]; 32 / 8];
            for i in 0..32 / 8 {
                bytes[i] = words[i].to_le_bytes();
            }
            unsafe { std::mem::transmute(bytes) }
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 32] {
            grow_be_uint::<INPUT_SIZE, 32>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 32] {
            grow_le_uint::<INPUT_SIZE, 32>(data)
        }
    }
    impl Bytable<64> for U512 {
        fn from_be_bytes(bytes: [u8; 64]) -> Self {
            Self::from_be_slice(&bytes).unwrap()
        }
        fn from_le_bytes(bytes: [u8; 64]) -> Self {
            Self::from_le_slice(&bytes).unwrap()
        }
        fn to_be_bytes(self) -> [u8; 64] {
            let words = self.digits();
            let mut bytes = [[0u8; 8]; 64 / 8];
            for i in 0..64 / 8 {
                bytes[i] = words[64 / 8 - i - 1].to_be_bytes();
            }
            unsafe { std::mem::transmute(bytes) }
        }
        fn to_le_bytes(self) -> [u8; 64] {
            let words = self.digits();
            let mut bytes = [[0u8; 8]; 64 / 8];
            for i in 0..64 / 8 {
                bytes[i] = words[i].to_le_bytes();
            }
            unsafe { std::mem::transmute(bytes) }
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 64] {
            grow_be_uint::<INPUT_SIZE, 64>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 64] {
            grow_le_uint::<INPUT_SIZE, 64>(data)
        }
    }
    impl Bytable<32> for I256 {
        fn from_be_bytes(bytes: [u8; 32]) -> Self {
            Self::from_be_slice(&bytes).unwrap()
        }
        fn from_le_bytes(bytes: [u8; 32]) -> Self {
            Self::from_le_slice(&bytes).unwrap()
        }
        fn to_be_bytes(self) -> [u8; 32] {
            self.to_bits().to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 32] {
            self.to_bits().to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 32] {
            grow_be_int::<INPUT_SIZE, 32>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 32] {
            grow_le_int::<INPUT_SIZE, 32>(data)
        }
    }
    impl Bytable<64> for I512 {
        fn from_be_bytes(bytes: [u8; 64]) -> Self {
            Self::from_be_slice(&bytes).unwrap()
        }
        fn from_le_bytes(bytes: [u8; 64]) -> Self {
            Self::from_le_slice(&bytes).unwrap()
        }
        fn to_be_bytes(self) -> [u8; 64] {
            self.to_bits().to_be_bytes()
        }
        fn to_le_bytes(self) -> [u8; 64] {
            self.to_bits().to_le_bytes()
        }
        fn grow_be_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 64] {
            grow_be_int::<INPUT_SIZE, 64>(data)
        }
        fn grow_le_bytes<const INPUT_SIZE: usize>(data: [u8; INPUT_SIZE]) -> [u8; 64] {
            grow_le_int::<INPUT_SIZE, 64>(data)
        }
    }
}
mod decimal {
    use crate::{FixedPoint, MathResult, Number, Udec};
    /// Describes operations that decimal types must implement, which may not be
    /// relevant for non-decimal types.
    pub trait Decimal: Sized {
        fn checked_floor(self) -> MathResult<Self>;
        fn checked_ceil(self) -> MathResult<Self>;
    }
    impl<U> Decimal for Udec<U>
    where
        Self: FixedPoint<U>,
        U: Number + Copy + PartialEq,
    {
        fn checked_floor(self) -> MathResult<Self> {
            Ok(Self(self.0 - self.0.checked_rem(Self::DECIMAL_FRACTION)?))
        }
        fn checked_ceil(self) -> MathResult<Self> {
            let floor = self.checked_floor()?;
            if floor == self {
                Ok(floor)
            } else {
                floor.0.checked_add(Self::DECIMAL_FRACTION).map(Self)
            }
        }
    }
}
mod error {
    use {std::any::type_name, thiserror::Error};
    pub enum MathError {
        #[error("failed to parse string `{input}` into {ty}: {reason}")]
        ParseNumber { ty: &'static str, input: String, reason: String },
        #[error("conversion overflow: {source_type}({value}) > {target_type}::MAX")]
        OverflowConversion {
            source_type: &'static str,
            target_type: &'static str,
            value: String,
        },
        #[error("addition overflow: {a} + {b} > {ty}::MAX")]
        OverflowAdd { ty: &'static str, a: String, b: String },
        #[error("subtraction overflow: {a} - {b} < {ty}::MIN")]
        OverflowSub { ty: &'static str, a: String, b: String },
        #[error("multiplication overflow: {a} * {b} > {ty}::MAX")]
        OverflowMul { ty: &'static str, a: String, b: String },
        #[error("power overflow: {a} ^ {b} > {ty}::MAX")]
        OverflowPow { ty: &'static str, a: String, b: String },
        #[error("left shift overflow: {a} << {b}")]
        OverflowShl { a: String, b: u32 },
        #[error("right shift overflow: {a} >> {b}")]
        OverflowShr { a: String, b: u32 },
        #[error("division by zero: {a} / 0")]
        DivisionByZero { a: String },
        #[error("remainder by zero: {a} % 0")]
        RemainderByZero { a: String },
        #[error("multiply a non-negative lhs with a negative rhs: {ty}({a}) * {b}")]
        NegativeMul { ty: &'static str, a: String, b: String },
        #[error("divide a non-negative lhs with a negative rhs: {ty}({a}) / {b}")]
        NegativeDiv { ty: &'static str, a: String, b: String },
        #[error("square root of negative: sqrt({a})")]
        NegativeSqrt { a: String },
        #[error("square root failed")]
        SqrtFailed,
        #[error("logarithm of zero")]
        ZeroLog,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MathError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MathError::ParseNumber {
                    ty: __self_0,
                    input: __self_1,
                    reason: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ParseNumber",
                        "ty",
                        __self_0,
                        "input",
                        __self_1,
                        "reason",
                        &__self_2,
                    )
                }
                MathError::OverflowConversion {
                    source_type: __self_0,
                    target_type: __self_1,
                    value: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "OverflowConversion",
                        "source_type",
                        __self_0,
                        "target_type",
                        __self_1,
                        "value",
                        &__self_2,
                    )
                }
                MathError::OverflowAdd { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "OverflowAdd",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::OverflowSub { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "OverflowSub",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::OverflowMul { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "OverflowMul",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::OverflowPow { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "OverflowPow",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::OverflowShl { a: __self_0, b: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OverflowShl",
                        "a",
                        __self_0,
                        "b",
                        &__self_1,
                    )
                }
                MathError::OverflowShr { a: __self_0, b: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OverflowShr",
                        "a",
                        __self_0,
                        "b",
                        &__self_1,
                    )
                }
                MathError::DivisionByZero { a: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "DivisionByZero",
                        "a",
                        &__self_0,
                    )
                }
                MathError::RemainderByZero { a: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "RemainderByZero",
                        "a",
                        &__self_0,
                    )
                }
                MathError::NegativeMul { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NegativeMul",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::NegativeDiv { ty: __self_0, a: __self_1, b: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NegativeDiv",
                        "ty",
                        __self_0,
                        "a",
                        __self_1,
                        "b",
                        &__self_2,
                    )
                }
                MathError::NegativeSqrt { a: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "NegativeSqrt",
                        "a",
                        &__self_0,
                    )
                }
                MathError::SqrtFailed => {
                    ::core::fmt::Formatter::write_str(f, "SqrtFailed")
                }
                MathError::ZeroLog => ::core::fmt::Formatter::write_str(f, "ZeroLog"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MathError {
        #[inline]
        fn clone(&self) -> MathError {
            match self {
                MathError::ParseNumber {
                    ty: __self_0,
                    input: __self_1,
                    reason: __self_2,
                } => {
                    MathError::ParseNumber {
                        ty: ::core::clone::Clone::clone(__self_0),
                        input: ::core::clone::Clone::clone(__self_1),
                        reason: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowConversion {
                    source_type: __self_0,
                    target_type: __self_1,
                    value: __self_2,
                } => {
                    MathError::OverflowConversion {
                        source_type: ::core::clone::Clone::clone(__self_0),
                        target_type: ::core::clone::Clone::clone(__self_1),
                        value: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowAdd { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::OverflowAdd {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowSub { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::OverflowSub {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowMul { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::OverflowMul {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowPow { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::OverflowPow {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::OverflowShl { a: __self_0, b: __self_1 } => {
                    MathError::OverflowShl {
                        a: ::core::clone::Clone::clone(__self_0),
                        b: ::core::clone::Clone::clone(__self_1),
                    }
                }
                MathError::OverflowShr { a: __self_0, b: __self_1 } => {
                    MathError::OverflowShr {
                        a: ::core::clone::Clone::clone(__self_0),
                        b: ::core::clone::Clone::clone(__self_1),
                    }
                }
                MathError::DivisionByZero { a: __self_0 } => {
                    MathError::DivisionByZero {
                        a: ::core::clone::Clone::clone(__self_0),
                    }
                }
                MathError::RemainderByZero { a: __self_0 } => {
                    MathError::RemainderByZero {
                        a: ::core::clone::Clone::clone(__self_0),
                    }
                }
                MathError::NegativeMul { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::NegativeMul {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::NegativeDiv { ty: __self_0, a: __self_1, b: __self_2 } => {
                    MathError::NegativeDiv {
                        ty: ::core::clone::Clone::clone(__self_0),
                        a: ::core::clone::Clone::clone(__self_1),
                        b: ::core::clone::Clone::clone(__self_2),
                    }
                }
                MathError::NegativeSqrt { a: __self_0 } => {
                    MathError::NegativeSqrt {
                        a: ::core::clone::Clone::clone(__self_0),
                    }
                }
                MathError::SqrtFailed => MathError::SqrtFailed,
                MathError::ZeroLog => MathError::ZeroLog,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for MathError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for MathError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                MathError::ParseNumber { ty, input, reason } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "failed to parse string `{0}` into {1}: {2}",
                                input.as_display(),
                                ty.as_display(),
                                reason.as_display(),
                            ),
                        )
                }
                MathError::OverflowConversion { source_type, target_type, value } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "conversion overflow: {0}({1}) > {2}::MAX",
                                source_type.as_display(),
                                value.as_display(),
                                target_type.as_display(),
                            ),
                        )
                }
                MathError::OverflowAdd { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "addition overflow: {0} + {1} > {2}::MAX",
                                a.as_display(),
                                b.as_display(),
                                ty.as_display(),
                            ),
                        )
                }
                MathError::OverflowSub { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "subtraction overflow: {0} - {1} < {2}::MIN",
                                a.as_display(),
                                b.as_display(),
                                ty.as_display(),
                            ),
                        )
                }
                MathError::OverflowMul { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "multiplication overflow: {0} * {1} > {2}::MAX",
                                a.as_display(),
                                b.as_display(),
                                ty.as_display(),
                            ),
                        )
                }
                MathError::OverflowPow { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "power overflow: {0} ^ {1} > {2}::MAX",
                                a.as_display(),
                                b.as_display(),
                                ty.as_display(),
                            ),
                        )
                }
                MathError::OverflowShl { a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "left shift overflow: {0} << {1}",
                                a.as_display(),
                                b.as_display(),
                            ),
                        )
                }
                MathError::OverflowShr { a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "right shift overflow: {0} >> {1}",
                                a.as_display(),
                                b.as_display(),
                            ),
                        )
                }
                MathError::DivisionByZero { a } => {
                    __formatter
                        .write_fmt(
                            format_args!("division by zero: {0} / 0", a.as_display()),
                        )
                }
                MathError::RemainderByZero { a } => {
                    __formatter
                        .write_fmt(
                            format_args!("remainder by zero: {0} % 0", a.as_display()),
                        )
                }
                MathError::NegativeMul { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "multiply a non-negative lhs with a negative rhs: {0}({1}) * {2}",
                                ty.as_display(),
                                a.as_display(),
                                b.as_display(),
                            ),
                        )
                }
                MathError::NegativeDiv { ty, a, b } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "divide a non-negative lhs with a negative rhs: {0}({1}) / {2}",
                                ty.as_display(),
                                a.as_display(),
                                b.as_display(),
                            ),
                        )
                }
                MathError::NegativeSqrt { a } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "square root of negative: sqrt({0})",
                                a.as_display(),
                            ),
                        )
                }
                MathError::SqrtFailed {} => __formatter.write_str("square root failed"),
                MathError::ZeroLog {} => __formatter.write_str("logarithm of zero"),
            }
        }
    }
    impl MathError {
        pub fn parse_number<T, V, R>(input: V, reason: R) -> Self
        where
            V: ToString,
            R: ToString,
        {
            Self::ParseNumber {
                ty: type_name::<T>(),
                input: input.to_string(),
                reason: reason.to_string(),
            }
        }
        pub fn overflow_conversion<A, B>(source: A) -> Self
        where
            A: ToString,
        {
            Self::OverflowConversion {
                source_type: type_name::<A>(),
                target_type: type_name::<B>(),
                value: source.to_string(),
            }
        }
        pub fn overflow_add<T>(a: T, b: T) -> Self
        where
            T: ToString,
        {
            Self::OverflowAdd {
                ty: type_name::<T>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn overflow_sub<T>(a: T, b: T) -> Self
        where
            T: ToString,
        {
            Self::OverflowSub {
                ty: type_name::<T>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn overflow_mul<T>(a: T, b: T) -> Self
        where
            T: ToString,
        {
            Self::OverflowMul {
                ty: type_name::<T>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn overflow_pow<T>(a: T, b: u32) -> Self
        where
            T: ToString,
        {
            Self::OverflowPow {
                ty: type_name::<T>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn overflow_shl<T>(a: T, b: u32) -> Self
        where
            T: ToString,
        {
            Self::OverflowShl {
                a: a.to_string(),
                b,
            }
        }
        pub fn overflow_shr<T>(a: T, b: u32) -> Self
        where
            T: ToString,
        {
            Self::OverflowShr {
                a: a.to_string(),
                b,
            }
        }
        pub fn division_by_zero<T>(a: T) -> Self
        where
            T: ToString,
        {
            Self::DivisionByZero {
                a: a.to_string(),
            }
        }
        pub fn remainder_by_zero<T>(a: T) -> Self
        where
            T: ToString,
        {
            Self::RemainderByZero {
                a: a.to_string(),
            }
        }
        pub fn negative_mul<A, B>(a: A, b: B) -> Self
        where
            A: ToString,
            B: ToString,
        {
            Self::NegativeMul {
                ty: type_name::<A>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn negative_div<A, B>(a: A, b: B) -> Self
        where
            A: ToString,
            B: ToString,
        {
            Self::NegativeDiv {
                ty: type_name::<A>(),
                a: a.to_string(),
                b: b.to_string(),
            }
        }
        pub fn negative_sqrt<T>(a: T) -> Self
        where
            T: ToString,
        {
            Self::NegativeSqrt {
                a: a.to_string(),
            }
        }
        pub fn zero_log() -> Self {
            Self::ZeroLog
        }
    }
    pub type MathResult<T> = Result<T, MathError>;
}
mod fixed_point {
    use {
        crate::{
            Dec128, Dec256, Int128, Int256, Udec128, Udec256, Uint, Uint128, Uint256,
        },
        bnum::types::{I256, U256},
    };
    /// Describes a [fixed-point decimal](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)
    /// number.
    pub trait FixedPoint<U> {
        /// Ratio between the inner integer value and the decimal value it
        /// represents.
        const DECIMAL_FRACTION: Uint<U>;
        /// Number of decimal digits to be interpreted as decimal places.
        const DECIMAL_PLACES: u32;
    }
    impl FixedPoint<u128> for Udec128 {
        const DECIMAL_FRACTION: Uint128 = Uint128::new(
            10_u128.pow(Self::DECIMAL_PLACES),
        );
        const DECIMAL_PLACES: u32 = 18;
    }
    impl FixedPoint<U256> for Udec256 {
        const DECIMAL_FRACTION: Uint256 = Uint256::new_from_u128(
            10_u128.pow(Self::DECIMAL_PLACES),
        );
        const DECIMAL_PLACES: u32 = 18;
    }
    impl FixedPoint<i128> for Dec128 {
        const DECIMAL_FRACTION: Int128 = Int128::new(10_i128.pow(Self::DECIMAL_PLACES));
        const DECIMAL_PLACES: u32 = 18;
    }
    impl FixedPoint<I256> for Dec256 {
        const DECIMAL_FRACTION: Int256 = Int256::new_from_i128(
            10_i128.pow(Self::DECIMAL_PLACES),
        );
        const DECIMAL_PLACES: u32 = 18;
    }
}
mod fraction {
    use crate::{FixedPoint, MathResult, MultiplyRatio, Udec, Uint};
    /// Describes a number that can be expressed as the quotient of two integers.
    ///
    /// Note that here we only concern the fraction's absolute value. Both the
    /// numerator and denominator here are negative. This trait is intended to be
    /// used together with [`Sign`] To account for negative fractions.
    pub trait Fraction<U>: Sized {
        fn numerator(&self) -> Uint<U>;
        fn denominator() -> Uint<U>;
        fn checked_inv(&self) -> MathResult<Self>;
    }
    impl<U> Fraction<U> for Udec<U>
    where
        Self: FixedPoint<U>,
        U: Copy,
        Uint<U>: MultiplyRatio,
    {
        fn numerator(&self) -> Uint<U> {
            self.0
        }
        fn denominator() -> Uint<U> {
            Self::DECIMAL_FRACTION
        }
        fn checked_inv(&self) -> MathResult<Self> {
            Self::checked_from_ratio(Self::DECIMAL_FRACTION, self.0)
        }
    }
}
mod inner {
    use crate::{Udec, Uint};
    /// Describes a type that wraps another type.
    ///
    /// This trait is used in [`generate_uint!`](crate::generate_uint!) and
    /// [`generate_decimal!`](crate::generate_decimal!) to get the inner type of a
    /// [`Uint`] and implement the conversion from the inner type to the [`Uint`].
    pub trait Inner {
        type U;
    }
    impl<U> Inner for Uint<U> {
        type U = U;
    }
    impl<U> Inner for Udec<U> {
        type U = U;
    }
}
mod integer {
    use {
        crate::{MathError, MathResult, Uint},
        bnum::types::{I256, I512, U256, U512},
    };
    /// Describes operations that integer types must implement, which may not be
    /// relevant for non-integer types.
    pub trait Integer: Sized {
        fn checked_ilog2(self) -> MathResult<u32>;
        fn checked_ilog10(self) -> MathResult<u32>;
        fn checked_shl(self, other: u32) -> MathResult<Self>;
        fn checked_shr(self, other: u32) -> MathResult<Self>;
    }
    impl<U> Integer for Uint<U>
    where
        U: Integer,
    {
        fn checked_ilog2(self) -> MathResult<u32> {
            self.0.checked_ilog2()
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.0.checked_ilog10()
        }
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.0.checked_shl(other).map(Self)
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.0.checked_shr(other).map(Self)
        }
    }
    impl Integer for u8 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for u16 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for u32 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for u64 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for u128 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for U256 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for U512 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for i8 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for i16 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for i32 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for i64 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for i128 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for I256 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
    impl Integer for I512 {
        fn checked_shl(self, other: u32) -> MathResult<Self> {
            self.checked_shl(other).ok_or_else(|| MathError::overflow_shl(self, other))
        }
        fn checked_shr(self, other: u32) -> MathResult<Self> {
            self.checked_shr(other).ok_or_else(|| MathError::overflow_shr(self, other))
        }
        fn checked_ilog2(self) -> MathResult<u32> {
            self.checked_ilog2().ok_or_else(|| MathError::zero_log())
        }
        fn checked_ilog10(self) -> MathResult<u32> {
            self.checked_ilog10().ok_or_else(|| MathError::zero_log())
        }
    }
}
mod is_zero {
    use {
        crate::{NumberConst, Udec, Uint},
        bnum::types::{I256, I512, U256, U512},
    };
    pub trait IsZero {
        fn is_zero(&self) -> bool;
    }
    impl<U> IsZero for Uint<U>
    where
        U: IsZero,
    {
        fn is_zero(&self) -> bool {
            self.0.is_zero()
        }
    }
    impl<U> IsZero for Udec<U>
    where
        U: IsZero,
    {
        fn is_zero(&self) -> bool {
            self.0.is_zero()
        }
    }
    impl IsZero for u8 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for u16 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for u32 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for u64 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for u128 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for U256 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for U512 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for i8 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for i16 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for i32 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for i64 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for i128 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for I256 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
    impl IsZero for I512 {
        fn is_zero(&self) -> bool {
            *self == Self::ZERO
        }
    }
}
mod multiply_fraction {
    use crate::{
        Fraction, IsZero, MathError, MathResult, MultiplyRatio, Number, NumberConst,
        Sign, Uint,
    };
    /// Describes operations between a number and a decimal type.
    pub trait MultiplyFraction<F, U>: Sized
    where
        F: Fraction<U>,
    {
        fn checked_mul_dec_floor(self, rhs: F) -> MathResult<Self>;
        fn checked_mul_dec_ceil(self, rhs: F) -> MathResult<Self>;
        fn checked_div_dec_floor(self, rhs: F) -> MathResult<Self>;
        fn checked_div_dec_ceil(self, rhs: F) -> MathResult<Self>;
    }
    impl<U, AsU, F> MultiplyFraction<F, AsU> for Uint<U>
    where
        Uint<
            U,
        >: NumberConst + Number + IsZero + MultiplyRatio + From<Uint<AsU>> + ToString,
        F: Number + Fraction<AsU> + Sign + ToString + IsZero,
    {
        fn checked_mul_dec_floor(self, rhs: F) -> MathResult<Self> {
            if self.is_zero() || rhs.is_zero() {
                return Ok(Self::ZERO);
            }
            if rhs.is_negative() {
                return Err(MathError::negative_mul(self, rhs));
            }
            self.checked_multiply_ratio_floor(rhs.numerator(), F::denominator())
        }
        fn checked_mul_dec_ceil(self, rhs: F) -> MathResult<Self> {
            if self.is_zero() || rhs.is_zero() {
                return Ok(Self::ZERO);
            }
            if rhs.is_negative() {
                return Err(MathError::negative_mul(self, rhs));
            }
            self.checked_multiply_ratio_ceil(rhs.numerator(), F::denominator())
        }
        fn checked_div_dec_floor(self, rhs: F) -> MathResult<Self> {
            if rhs.is_zero() {
                return Err(MathError::division_by_zero(self));
            }
            if rhs.is_negative() {
                return Err(MathError::negative_div(self, rhs));
            }
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            self.checked_multiply_ratio_floor(F::denominator(), rhs.numerator())
        }
        fn checked_div_dec_ceil(self, rhs: F) -> MathResult<Self> {
            if rhs.is_zero() {
                return Err(MathError::division_by_zero(self));
            }
            if rhs.is_negative() {
                return Err(MathError::negative_div(self, rhs));
            }
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            self.checked_multiply_ratio_ceil(F::denominator(), rhs.numerator())
        }
    }
}
mod multiply_ratio {
    use crate::{IsZero, MathError, MathResult, NextNumber, Number, NumberConst, Uint};
    /// Describes operations where a number is multiplied by a numerator then
    /// immediately divided by a denominator.
    /// This is different from applying a multiplication and a division sequentially,
    /// because the multiplication part can overflow.
    pub trait MultiplyRatio: Sized {
        fn checked_multiply_ratio_floor<A, B>(
            self,
            numerator: A,
            denominator: B,
        ) -> MathResult<Self>
        where
            A: Into<Self>,
            B: Into<Self>;
        fn checked_multiply_ratio_ceil<A, B>(
            self,
            numerator: A,
            denominator: B,
        ) -> MathResult<Self>
        where
            A: Into<Self>,
            B: Into<Self>;
    }
    impl<U> MultiplyRatio for Uint<U>
    where
        Uint<U>: NextNumber + NumberConst + Number + Copy,
        <Uint<U> as NextNumber>::Next: Number + IsZero + ToString + Clone,
    {
        fn checked_multiply_ratio_floor<A: Into<Self>, B: Into<Self>>(
            self,
            numerator: A,
            denominator: B,
        ) -> MathResult<Self> {
            let denominator = denominator.into().into_next();
            let next_result = self
                .checked_full_mul(numerator)?
                .checked_div(denominator)?;
            next_result
                .clone()
                .try_into()
                .map_err(|_| MathError::overflow_conversion::<_, Self>(next_result))
        }
        fn checked_multiply_ratio_ceil<A: Into<Self>, B: Into<Self>>(
            self,
            numerator: A,
            denominator: B,
        ) -> MathResult<Self> {
            let numerator: Self = numerator.into();
            let denominator: Self = denominator.into();
            let dividend = self.checked_full_mul(numerator)?;
            let floor_result = self
                .checked_multiply_ratio_floor(numerator, denominator)?;
            let remained = dividend.checked_rem(denominator.into_next())?;
            if !remained.is_zero() {
                floor_result.checked_add(Self::ONE)
            } else {
                Ok(floor_result)
            }
        }
    }
}
mod next {
    use crate::{Int128, Int256, Int64, Uint128, Uint256, Uint512, Uint64};
    /// Describes a number type can be cast into another type of a bigger word size.
    ///
    /// For example, [`Uint128`](crate::Uint128) can be safety cast to [`Uint256`](crate::Uint256).
    /// In this case, [`NextNumber`] trait should be implemented for [`Uint128`](crate::Uint128)
    /// with `Next` being [`Uint256`](crate::Uint256).
    pub trait NextNumber: Sized + TryFrom<Self::Next> {
        type Next: From<Self>;
        fn into_next(self) -> Self::Next {
            self.into()
        }
    }
    impl NextNumber for Uint64 {
        type Next = Uint128;
    }
    impl NextNumber for Uint128 {
        type Next = Uint256;
    }
    impl NextNumber for Uint256 {
        type Next = Uint512;
    }
    impl NextNumber for Int64 {
        type Next = Int128;
    }
    impl NextNumber for Int128 {
        type Next = Int256;
    }
}
mod number {
    use {
        crate::{
            FixedPoint, Integer, IsZero, MathError, MathResult, NextNumber, NumberConst,
            Sign, Udec, Uint,
        },
        bnum::types::{I256, I512, U256, U512},
        std::fmt::Display,
    };
    /// Describes basic operations that all math types must implement.
    pub trait Number: Sized {
        fn checked_add(self, other: Self) -> MathResult<Self>;
        fn checked_sub(self, other: Self) -> MathResult<Self>;
        fn checked_mul(self, other: Self) -> MathResult<Self>;
        fn checked_div(self, other: Self) -> MathResult<Self>;
        fn checked_rem(self, other: Self) -> MathResult<Self>;
        fn checked_pow(self, other: u32) -> MathResult<Self>;
        fn checked_sqrt(self) -> MathResult<Self>;
        fn wrapping_add(self, other: Self) -> Self;
        fn wrapping_sub(self, other: Self) -> Self;
        fn wrapping_mul(self, other: Self) -> Self;
        fn wrapping_pow(self, other: u32) -> Self;
        fn saturating_add(self, other: Self) -> Self;
        fn saturating_sub(self, other: Self) -> Self;
        fn saturating_mul(self, other: Self) -> Self;
        fn saturating_pow(self, other: u32) -> Self;
    }
    impl<U> Number for Uint<U>
    where
        U: Number,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.0.checked_add(other.0).map(Self)
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.0.checked_sub(other.0).map(Self)
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.0.checked_mul(other.0).map(Self)
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.0.checked_div(other.0).map(Self)
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.0.checked_rem(other.0).map(Self)
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.0.checked_pow(other).map(Self)
        }
        fn checked_sqrt(self) -> MathResult<Self> {
            self.0.checked_sqrt().map(Self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            Self(self.0.wrapping_add(other.0))
        }
        fn wrapping_sub(self, other: Self) -> Self {
            Self(self.0.wrapping_sub(other.0))
        }
        fn wrapping_mul(self, other: Self) -> Self {
            Self(self.0.wrapping_mul(other.0))
        }
        fn wrapping_pow(self, other: u32) -> Self {
            Self(self.0.wrapping_pow(other))
        }
        fn saturating_add(self, other: Self) -> Self {
            Self(self.0.saturating_add(other.0))
        }
        fn saturating_sub(self, other: Self) -> Self {
            Self(self.0.saturating_sub(other.0))
        }
        fn saturating_mul(self, other: Self) -> Self {
            Self(self.0.saturating_mul(other.0))
        }
        fn saturating_pow(self, other: u32) -> Self {
            Self(self.0.saturating_pow(other))
        }
    }
    impl<U> Number for Udec<U>
    where
        Self: FixedPoint<U> + NumberConst,
        U: NumberConst + Number + IsZero + Copy + PartialEq + PartialOrd + Display,
        Uint<U>: NextNumber + Sign,
        <Uint<U> as NextNumber>::Next: Number + IsZero + Copy + ToString,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.0.checked_add(other.0).map(Self)
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.0.checked_sub(other.0).map(Self)
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            let next_result = self
                .0
                .checked_full_mul(*other.numerator())?
                .checked_div(Self::DECIMAL_FRACTION.into())?;
            next_result
                .try_into()
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint<U>>(next_result))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            Udec::checked_from_ratio(*self.numerator(), *other.numerator())
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.0.checked_rem(other.0).map(Self)
        }
        fn checked_pow(mut self, mut exp: u32) -> MathResult<Self> {
            if exp == 0 {
                return Ok(Self::ONE);
            }
            let mut y = Udec::ONE;
            while exp > 1 {
                if exp % 2 == 0 {
                    self = self.checked_mul(self)?;
                    exp /= 2;
                } else {
                    y = self.checked_mul(y)?;
                    self = self.checked_mul(self)?;
                    exp = (exp - 1) / 2;
                }
            }
            self.checked_mul(y)
        }
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.0 < Uint::ZERO {
                return Err(MathError::negative_sqrt::<Self>(self));
            }
            let hundred = Uint::TEN.checked_mul(Uint::TEN)?;
            (0..=Self::DECIMAL_PLACES / 2)
                .rev()
                .find_map(|i| -> Option<MathResult<Self>> {
                    let inner_mul = match hundred.checked_pow(i) {
                        Ok(val) => val,
                        Err(err) => return Some(Err(err)),
                    };
                    self.0
                        .checked_mul(inner_mul)
                        .ok()
                        .map(|inner| {
                            let outer_mul = Uint::TEN
                                .checked_pow(Self::DECIMAL_PLACES / 2 - i)?;
                            Ok(Self::raw(inner.checked_sqrt()?.checked_mul(outer_mul)?))
                        })
                })
                .transpose()?
                .ok_or(MathError::SqrtFailed)
        }
        fn wrapping_add(self, other: Self) -> Self {
            Self(self.0.wrapping_add(other.0))
        }
        fn wrapping_sub(self, other: Self) -> Self {
            Self(self.0.wrapping_sub(other.0))
        }
        fn wrapping_mul(self, other: Self) -> Self {
            Self(self.0.wrapping_mul(other.0))
        }
        fn wrapping_pow(self, other: u32) -> Self {
            Self(self.0.wrapping_pow(other))
        }
        fn saturating_add(self, other: Self) -> Self {
            Self(self.0.saturating_add(other.0))
        }
        fn saturating_sub(self, other: Self) -> Self {
            Self(self.0.saturating_sub(other.0))
        }
        fn saturating_mul(self, other: Self) -> Self {
            Self(self.0.saturating_mul(other.0))
        }
        fn saturating_pow(self, other: u32) -> Self {
            Self(self.0.saturating_pow(other))
        }
    }
    impl Number for u8
    where
        u8: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for u16
    where
        u16: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for u32
    where
        u32: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for u64
    where
        u64: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for u128
    where
        u128: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for U256
    where
        U256: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for U512
    where
        U512: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for i8
    where
        i8: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for i16
    where
        i16: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for i32
    where
        i32: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for i64
    where
        i64: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for i128
    where
        i128: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for I256
    where
        I256: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
    impl Number for I512
    where
        I512: NumberConst + Integer + IsZero,
    {
        fn checked_add(self, other: Self) -> MathResult<Self> {
            self.checked_add(other).ok_or_else(|| MathError::overflow_add(self, other))
        }
        fn checked_sub(self, other: Self) -> MathResult<Self> {
            self.checked_sub(other).ok_or_else(|| MathError::overflow_sub(self, other))
        }
        fn checked_mul(self, other: Self) -> MathResult<Self> {
            self.checked_mul(other).ok_or_else(|| MathError::overflow_mul(self, other))
        }
        fn checked_div(self, other: Self) -> MathResult<Self> {
            self.checked_div(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_rem(self, other: Self) -> MathResult<Self> {
            self.checked_rem(other).ok_or_else(|| MathError::division_by_zero(self))
        }
        fn checked_pow(self, other: u32) -> MathResult<Self> {
            self.checked_pow(other).ok_or_else(|| MathError::overflow_pow(self, other))
        }
        /// Compute a _positive_ integer's _floored_ square root using the
        /// [Babylonian method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).
        fn checked_sqrt(self) -> MathResult<Self> {
            if self.is_zero() {
                return Ok(Self::ZERO);
            }
            let mut x0 = Self::ONE << ((Integer::checked_ilog2(self)? / 2) + 1);
            if x0 > Self::ZERO {
                let mut x1 = (x0 + self / x0) >> 1;
                while x1 < x0 {
                    x0 = x1;
                    x1 = (x0 + self / x0) >> 1;
                }
                return Ok(x0);
            }
            Ok(self)
        }
        fn wrapping_add(self, other: Self) -> Self {
            self.wrapping_add(other)
        }
        fn wrapping_sub(self, other: Self) -> Self {
            self.wrapping_sub(other)
        }
        fn wrapping_mul(self, other: Self) -> Self {
            self.wrapping_mul(other)
        }
        fn wrapping_pow(self, other: u32) -> Self {
            self.wrapping_pow(other)
        }
        fn saturating_add(self, other: Self) -> Self {
            self.saturating_add(other)
        }
        fn saturating_sub(self, other: Self) -> Self {
            self.saturating_sub(other)
        }
        fn saturating_mul(self, other: Self) -> Self {
            self.saturating_mul(other)
        }
        fn saturating_pow(self, other: u32) -> Self {
            self.saturating_pow(other)
        }
    }
}
mod number_const {
    use bnum::types::{I256, I512, U256, U512};
    use crate::{
        Dec128, Dec256, FixedPoint, Int128, Int256, Udec128, Udec256, Uint, Uint128,
        Uint256,
    };
    /// Describes a number's associated constants: minimum and maximum; zero, one,
    /// and ten.
    pub trait NumberConst {
        const MIN: Self;
        const MAX: Self;
        const ONE: Self;
        const TEN: Self;
        const ZERO: Self;
    }
    impl<U> NumberConst for Uint<U>
    where
        U: NumberConst,
    {
        const MAX: Self = Self(U::MAX);
        const MIN: Self = Self(U::MIN);
        const ONE: Self = Self(U::ONE);
        const TEN: Self = Self(U::TEN);
        const ZERO: Self = Self(U::ZERO);
    }
    impl NumberConst for Udec128 {
        const MAX: Self = Self::raw(Uint128::MAX);
        const MIN: Self = Self::raw(Uint128::MIN);
        const ONE: Self = Self::raw(Self::DECIMAL_FRACTION);
        const TEN: Self = Self::raw(Uint128::new(10_u128.pow(Self::DECIMAL_PLACES + 1)));
        const ZERO: Self = Self::raw(Uint128::ZERO);
    }
    impl NumberConst for Udec256 {
        const MAX: Self = Self::raw(Uint256::MAX);
        const MIN: Self = Self::raw(Uint256::MIN);
        const ONE: Self = Self::raw(Self::DECIMAL_FRACTION);
        const TEN: Self = Self::raw(
            Uint256::new_from_u128(10_u128.pow(Self::DECIMAL_PLACES + 1)),
        );
        const ZERO: Self = Self::raw(Uint256::ZERO);
    }
    impl NumberConst for Dec128 {
        const MAX: Self = Self::raw(Int128::MAX);
        const MIN: Self = Self::raw(Int128::MIN);
        const ONE: Self = Self::raw(Self::DECIMAL_FRACTION);
        const TEN: Self = Self::raw(Int128::new(10_i128.pow(Self::DECIMAL_PLACES + 1)));
        const ZERO: Self = Self::raw(Int128::ZERO);
    }
    impl NumberConst for Dec256 {
        const MAX: Self = Self::raw(Int256::MAX);
        const MIN: Self = Self::raw(Int256::MIN);
        const ONE: Self = Self::raw(Self::DECIMAL_FRACTION);
        const TEN: Self = Self::raw(
            Int256::new_from_i128(10_i128.pow(Self::DECIMAL_PLACES + 1)),
        );
        const ZERO: Self = Self::raw(Int256::ZERO);
    }
    impl NumberConst for u8 {
        const MAX: Self = u8::MAX;
        const MIN: Self = 0;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: u8) {}
        _check_type(0);
        _check_type(u8::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for u16 {
        const MAX: Self = u16::MAX;
        const MIN: Self = 0;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: u16) {}
        _check_type(0);
        _check_type(u16::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for u32 {
        const MAX: Self = u32::MAX;
        const MIN: Self = 0;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: u32) {}
        _check_type(0);
        _check_type(u32::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for u64 {
        const MAX: Self = u64::MAX;
        const MIN: Self = 0;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: u64) {}
        _check_type(0);
        _check_type(u64::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for u128 {
        const MAX: Self = u128::MAX;
        const MIN: Self = 0;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: u128) {}
        _check_type(0);
        _check_type(u128::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for U256 {
        const MAX: Self = U256::MAX;
        const MIN: Self = U256::MIN;
        const ONE: Self = U256::ONE;
        const TEN: Self = U256::TEN;
        const ZERO: Self = U256::ZERO;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: U256) {}
        _check_type(U256::MIN);
        _check_type(U256::MAX);
        _check_type(U256::ZERO);
        _check_type(U256::ONE);
        _check_type(U256::TEN);
    };
    impl NumberConst for U512 {
        const MAX: Self = U512::MAX;
        const MIN: Self = U512::MIN;
        const ONE: Self = U512::ONE;
        const TEN: Self = U512::TEN;
        const ZERO: Self = U512::ZERO;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: U512) {}
        _check_type(U512::MIN);
        _check_type(U512::MAX);
        _check_type(U512::ZERO);
        _check_type(U512::ONE);
        _check_type(U512::TEN);
    };
    impl NumberConst for i8 {
        const MAX: Self = i8::MAX;
        const MIN: Self = i8::MIN;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: i8) {}
        _check_type(i8::MIN);
        _check_type(i8::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for i16 {
        const MAX: Self = i16::MAX;
        const MIN: Self = i16::MIN;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: i16) {}
        _check_type(i16::MIN);
        _check_type(i16::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for i32 {
        const MAX: Self = i32::MAX;
        const MIN: Self = i32::MIN;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: i32) {}
        _check_type(i32::MIN);
        _check_type(i32::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for i64 {
        const MAX: Self = i64::MAX;
        const MIN: Self = i64::MIN;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: i64) {}
        _check_type(i64::MIN);
        _check_type(i64::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for i128 {
        const MAX: Self = i128::MAX;
        const MIN: Self = i128::MIN;
        const ONE: Self = 1;
        const TEN: Self = 10;
        const ZERO: Self = 0;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: i128) {}
        _check_type(i128::MIN);
        _check_type(i128::MAX);
        _check_type(0);
        _check_type(1);
        _check_type(10);
    };
    impl NumberConst for I256 {
        const MAX: Self = I256::MAX;
        const MIN: Self = I256::MIN;
        const ONE: Self = I256::ONE;
        const TEN: Self = I256::TEN;
        const ZERO: Self = I256::ZERO;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: I256) {}
        _check_type(I256::MIN);
        _check_type(I256::MAX);
        _check_type(I256::ZERO);
        _check_type(I256::ONE);
        _check_type(I256::TEN);
    };
    impl NumberConst for I512 {
        const MAX: Self = I512::MAX;
        const MIN: Self = I512::MIN;
        const ONE: Self = I512::ONE;
        const TEN: Self = I512::TEN;
        const ZERO: Self = I512::ZERO;
    }
    /// A compile-time check to ensure that the constants are of the correct types.
    const _: () = {
        const fn _check_type(_: I512) {}
        _check_type(I512::MIN);
        _check_type(I512::MAX);
        _check_type(I512::ZERO);
        _check_type(I512::ONE);
        _check_type(I512::TEN);
    };
}
mod sign {
    use {
        crate::{NumberConst, Udec, Uint},
        bnum::types::{I256, I512, U256, U512},
    };
    /// Describes a number that can take on negative values.
    /// Zero is considered non-negative, for which this should return `false`.
    pub trait Sign {
        fn abs(self) -> Self;
        fn is_negative(&self) -> bool;
    }
    impl<U> Sign for Uint<U>
    where
        U: Sign,
    {
        fn abs(self) -> Self {
            Self(self.0.abs())
        }
        fn is_negative(&self) -> bool {
            self.0.is_negative()
        }
    }
    impl<U> Sign for Udec<U>
    where
        U: Sign,
    {
        fn abs(self) -> Self {
            Self(self.0.abs())
        }
        fn is_negative(&self) -> bool {
            self.0.is_negative()
        }
    }
    impl Sign for u8 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for u16 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for u32 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for u64 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for u128 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for U256 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for U512 {
        fn abs(self) -> Self {
            self
        }
        fn is_negative(&self) -> bool {
            false
        }
    }
    impl Sign for i8 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for i16 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for i32 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for i64 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for i128 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for I256 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
    impl Sign for I512 {
        fn abs(self) -> Self {
            self.abs()
        }
        fn is_negative(&self) -> bool {
            *self < Self::ZERO
        }
    }
}
mod udec {
    use {
        crate::{
            FixedPoint, Inner, Int128, Int256, IsZero, MathError, MathResult,
            MultiplyRatio, Number, NumberConst, Sign, Uint, Uint128, Uint256, Uint64,
        },
        bnum::types::{I256, U256},
        borsh::{BorshDeserialize, BorshSerialize},
        serde::{de, ser},
        std::{
            cmp::Ordering, fmt::{self, Display, Write},
            marker::PhantomData,
            ops::{
                Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Rem, RemAssign, Sub,
                SubAssign,
            },
            str::FromStr,
        },
    };
    pub struct Udec<U>(pub(crate) Uint<U>);
    impl<U> borsh::ser::BorshSerialize for Udec<U>
    where
        U: borsh::ser::BorshSerialize,
    {
        fn serialize<__W: borsh::io::Write>(
            &self,
            writer: &mut __W,
        ) -> ::core::result::Result<(), borsh::io::Error> {
            borsh::BorshSerialize::serialize(&self.0, writer)?;
            Ok(())
        }
    }
    impl<U> borsh::de::BorshDeserialize for Udec<U>
    where
        U: borsh::de::BorshDeserialize,
    {
        fn deserialize_reader<__R: borsh::io::Read>(
            reader: &mut __R,
        ) -> ::core::result::Result<Self, borsh::io::Error> {
            Ok(Self(borsh::BorshDeserialize::deserialize_reader(reader)?))
        }
    }
    #[automatically_derived]
    impl<U: ::core::default::Default> ::core::default::Default for Udec<U> {
        #[inline]
        fn default() -> Udec<U> {
            Udec(::core::default::Default::default())
        }
    }
    #[automatically_derived]
    impl<U: ::core::fmt::Debug> ::core::fmt::Debug for Udec<U> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Udec", &&self.0)
        }
    }
    #[automatically_derived]
    impl<U: ::core::clone::Clone> ::core::clone::Clone for Udec<U> {
        #[inline]
        fn clone(&self) -> Udec<U> {
            Udec(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<U: ::core::marker::Copy> ::core::marker::Copy for Udec<U> {}
    #[automatically_derived]
    impl<U> ::core::marker::StructuralPartialEq for Udec<U> {}
    #[automatically_derived]
    impl<U: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Udec<U> {
        #[inline]
        fn eq(&self, other: &Udec<U>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::Eq> ::core::cmp::Eq for Udec<U> {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Uint<U>>;
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Udec<U> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Udec<U>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::Ord> ::core::cmp::Ord for Udec<U> {
        #[inline]
        fn cmp(&self, other: &Udec<U>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    impl<U> Udec<U> {
        /// Create a new [`Udec`] _without_ adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let uint = Uint128::new(100);
        /// let decimal = Udec128::raw(uint);
        /// assert_eq!(decimal, Udec128::from_str("0.000000000000000100").unwrap());
        /// ```
        pub const fn raw(value: Uint<U>) -> Self {
            Self(value)
        }
        pub fn numerator(&self) -> &Uint<U> {
            &self.0
        }
    }
    impl<U> Udec<U>
    where
        Self: FixedPoint<U>,
        Uint<U>: NumberConst + Number,
    {
        pub fn checked_from_atomics<T>(
            atomics: T,
            decimal_places: u32,
        ) -> MathResult<Self>
        where
            T: Into<Uint<U>>,
        {
            let atomics = atomics.into();
            let inner = match decimal_places.cmp(&Self::DECIMAL_PLACES) {
                Ordering::Less => {
                    let digits = Self::DECIMAL_PLACES - decimal_places;
                    let factor = Uint::<U>::TEN.checked_pow(digits)?;
                    atomics.checked_mul(factor)?
                }
                Ordering::Equal => atomics,
                Ordering::Greater => {
                    let digits = decimal_places - Self::DECIMAL_PLACES;
                    if let Ok(factor) = Uint::<U>::TEN.checked_pow(digits) {
                        atomics.checked_div(factor).unwrap()
                    } else {
                        Uint::<U>::ZERO
                    }
                }
            };
            Ok(Self(inner))
        }
    }
    impl<U> Udec<U>
    where
        Self: FixedPoint<U>,
        Uint<U>: MultiplyRatio,
    {
        pub fn checked_from_ratio<N, D>(numerator: N, denominator: D) -> MathResult<Self>
        where
            N: Into<Uint<U>>,
            D: Into<Uint<U>>,
        {
            let numerator = numerator.into();
            let denominator = denominator.into();
            numerator
                .checked_multiply_ratio_floor(Self::DECIMAL_FRACTION, denominator)
                .map(Self)
        }
    }
    impl<U> Udec<U>
    where
        Self: FixedPoint<U>,
        U: NumberConst + Number,
    {
        pub fn from_decimal<OU>(other: Udec<OU>) -> Self
        where
            Uint<U>: From<Uint<OU>>,
            Udec<OU>: FixedPoint<OU>,
        {
            if Udec::<OU>::DECIMAL_PLACES > Udec::<U>::DECIMAL_PLACES {
                let adjusted_precision = Uint::<U>::TEN
                    .checked_pow(Udec::<OU>::DECIMAL_PLACES - Udec::<U>::DECIMAL_PLACES)
                    .unwrap();
                Self(Uint::<U>::from(other.0) / adjusted_precision)
            } else {
                let adjusted_precision = Uint::<U>::TEN
                    .checked_pow(Udec::<U>::DECIMAL_PLACES - Udec::<OU>::DECIMAL_PLACES)
                    .unwrap();
                Self(Uint::<U>::from(other.0) * adjusted_precision)
            }
        }
        pub fn try_from_decimal<OU>(other: Udec<OU>) -> MathResult<Self>
        where
            Uint<U>: TryFrom<Uint<OU>>,
            MathError: From<<Uint<U> as TryFrom<Uint<OU>>>::Error>,
            Udec<OU>: FixedPoint<OU>,
        {
            if Udec::<OU>::DECIMAL_PLACES > Udec::<U>::DECIMAL_PLACES {
                let adjusted_precision = Uint::<U>::TEN
                    .checked_pow(
                        Udec::<OU>::DECIMAL_PLACES - Udec::<U>::DECIMAL_PLACES,
                    )?;
                Uint::<U>::try_from(other.0)
                    .map(|val| val.checked_div(adjusted_precision))?
                    .map(Self)
            } else {
                let adjusted_precision = Uint::<U>::TEN
                    .checked_pow(
                        Udec::<U>::DECIMAL_PLACES - Udec::<OU>::DECIMAL_PLACES,
                    )?;
                Uint::<U>::try_from(other.0)
                    .map(|val| val.checked_mul(adjusted_precision))?
                    .map(Self)
            }
        }
    }
    impl<U> Neg for Udec<U>
    where
        U: Neg<Output = U>,
    {
        type Output = Self;
        fn neg(self) -> Self::Output {
            Self(-self.0)
        }
    }
    impl<U> Display for Udec<U>
    where
        Self: FixedPoint<U>,
        U: Number + IsZero + Display,
        Uint<U>: Copy + Sign,
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let decimals = Self::DECIMAL_FRACTION;
            let whole = (self.0) / decimals;
            let fractional = (self.0).checked_rem(decimals).unwrap();
            if fractional.is_zero() {
                f.write_fmt(format_args!("{0}", whole))?;
            } else {
                let fractional_string = {
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0:0>1$}",
                            fractional.abs().0,
                            Self::DECIMAL_PLACES as usize,
                        ),
                    );
                    res
                };
                if whole.is_negative() || fractional.is_negative() {
                    f.write_char('-')?;
                }
                f.write_str(&whole.abs().to_string())?;
                f.write_char('.')?;
                f.write_str(fractional_string.trim_end_matches('0'))?;
            }
            Ok(())
        }
    }
    impl<U> FromStr for Udec<U>
    where
        Self: FixedPoint<U>,
        Uint<U>: NumberConst + Number + Display + FromStr,
    {
        type Err = MathError;
        /// Converts the decimal string to a Udec
        /// Possible inputs: "1.23", "1", "000012", "1.123000000"
        /// Disallowed: "", ".23"
        ///
        /// This never performs any kind of rounding.
        /// More than DECIMAL_PLACES fractional digits, even zeros, result in an error.
        fn from_str(input: &str) -> Result<Self, Self::Err> {
            let mut parts_iter = input.split('.');
            let mut atomics = parts_iter
                .next()
                .unwrap()
                .parse::<Uint<U>>()
                .map_err(|_| MathError::parse_number::<
                    Self,
                    _,
                    _,
                >(input, "error parsing whole"))?
                .checked_mul(Self::DECIMAL_FRACTION)
                .map_err(|_| MathError::parse_number::<
                    Self,
                    _,
                    _,
                >(input, "value too big"))?;
            if let Some(fractional_part) = parts_iter.next() {
                let fractional = fractional_part
                    .parse::<Uint<U>>()
                    .map_err(|_| {
                        MathError::parse_number::<
                            Self,
                            _,
                            _,
                        >(input, "error parsing fractional")
                    })?;
                let exp = (Self::DECIMAL_PLACES
                    .checked_sub(fractional_part.len() as u32))
                    .ok_or_else(|| {
                        MathError::parse_number::<
                            Self,
                            _,
                            _,
                        >(
                            input,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "cannot parse more than {0} fractional digits",
                                        Self::DECIMAL_FRACTION,
                                    ),
                                );
                                res
                            },
                        )
                    })?;
                if true {
                    if !(exp <= Self::DECIMAL_PLACES) {
                        ::core::panicking::panic(
                            "assertion failed: exp <= Self::DECIMAL_PLACES",
                        )
                    }
                }
                let fractional_factor = Uint::TEN.checked_pow(exp).unwrap();
                let fractional_part = fractional.checked_mul(fractional_factor).unwrap();
                atomics = if input.starts_with("-") {
                    atomics.checked_sub(fractional_part)
                } else {
                    atomics.checked_add(fractional_part)
                }
                    .map_err(|_| MathError::parse_number::<
                        Self,
                        _,
                        _,
                    >(input, "Value too big"))?;
            }
            if parts_iter.next().is_some() {
                return Err(
                    MathError::parse_number::<
                        Self,
                        _,
                        _,
                    >(input, "Unexpected number of dots"),
                );
            }
            Ok(Udec(atomics))
        }
    }
    impl<U> ser::Serialize for Udec<U>
    where
        Self: Display,
    {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }
    impl<'de, U> de::Deserialize<'de> for Udec<U>
    where
        Udec<U>: FromStr,
        <Udec<U> as FromStr>::Err: Display,
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            deserializer.deserialize_str(UdecVisitor::new())
        }
    }
    struct UdecVisitor<U> {
        _marker: PhantomData<U>,
    }
    impl<U> UdecVisitor<U> {
        pub fn new() -> Self {
            Self { _marker: PhantomData }
        }
    }
    impl<'de, U> de::Visitor<'de> for UdecVisitor<U>
    where
        Udec<U>: FromStr,
        <Udec<U> as FromStr>::Err: Display,
    {
        type Value = Udec<U>;
        fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.write_str("string-encoded decimal")
        }
        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Udec::from_str(v).map_err(E::custom)
        }
    }
    impl<U> Add for Udec<U>
    where
        Self: Number,
    {
        type Output = Self;
        fn add(self, rhs: Self) -> Self::Output {
            self.checked_add(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Sub for Udec<U>
    where
        Self: Number,
    {
        type Output = Self;
        fn sub(self, rhs: Self) -> Self::Output {
            self.checked_sub(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Mul for Udec<U>
    where
        Self: Number,
    {
        type Output = Self;
        fn mul(self, rhs: Self) -> Self::Output {
            self.checked_mul(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Div for Udec<U>
    where
        Self: Number,
    {
        type Output = Self;
        fn div(self, rhs: Self) -> Self::Output {
            self.checked_div(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Rem for Udec<U>
    where
        Self: Number,
    {
        type Output = Self;
        fn rem(self, rhs: Self) -> Self::Output {
            self.checked_rem(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> AddAssign for Udec<U>
    where
        Self: Number + Copy,
    {
        fn add_assign(&mut self, rhs: Self) {
            *self = *self + rhs;
        }
    }
    impl<U> SubAssign for Udec<U>
    where
        Self: Number + Copy,
    {
        fn sub_assign(&mut self, rhs: Self) {
            *self = *self - rhs;
        }
    }
    impl<U> MulAssign for Udec<U>
    where
        Self: Number + Copy,
    {
        fn mul_assign(&mut self, rhs: Self) {
            *self = *self * rhs;
        }
    }
    impl<U> DivAssign for Udec<U>
    where
        Self: Number + Copy,
    {
        fn div_assign(&mut self, rhs: Self) {
            *self = *self / rhs;
        }
    }
    impl<U> RemAssign for Udec<U>
    where
        Self: Number + Copy,
    {
        fn rem_assign(&mut self, rhs: Self) {
            *self = *self % rhs;
        }
    }
    ///128-bit unsigned fixed-point number with 18 decimal places.
    pub type Udec128 = Udec<u128>;
    impl Udec128 {
        /// Create a new [`Udec`] adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let decimal = Udec128::new(100);
        /// assert_eq!(decimal, Udec128::from_str("100.0").unwrap());
        /// ```
        pub const fn new(x: u128) -> Self {
            Self(Uint128::new(x * 10_u128.pow(Self::DECIMAL_PLACES)))
        }
        pub const fn new_percent(x: u128) -> Self {
            Self(Uint128::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 2)))
        }
        pub const fn new_permille(x: u128) -> Self {
            Self(Uint128::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 3)))
        }
        pub const fn new_bps(x: u128) -> Self {
            Self(Uint128::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 4)))
        }
    }
    impl From<u128> for Udec128 {
        fn from(value: u128) -> Self {
            Self::raw(Uint::new(value))
        }
    }
    impl From<Uint<u128>> for Udec128 {
        fn from(value: Uint<u128>) -> Self {
            Self::raw(value)
        }
    }
    ///256-bit unsigned fixed-point number with 18 decimal places.
    pub type Udec256 = Udec<U256>;
    impl Udec256 {
        /// Create a new [`Udec`] adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let decimal = Udec128::new(100);
        /// assert_eq!(decimal, Udec128::from_str("100.0").unwrap());
        /// ```
        pub const fn new(x: u128) -> Self {
            Self(Uint256::new_from_u128(x * 10_u128.pow(Self::DECIMAL_PLACES)))
        }
        pub const fn new_percent(x: u128) -> Self {
            Self(Uint256::new_from_u128(x * 10_u128.pow(Self::DECIMAL_PLACES - 2)))
        }
        pub const fn new_permille(x: u128) -> Self {
            Self(Uint256::new_from_u128(x * 10_u128.pow(Self::DECIMAL_PLACES - 3)))
        }
        pub const fn new_bps(x: u128) -> Self {
            Self(Uint256::new_from_u128(x * 10_u128.pow(Self::DECIMAL_PLACES - 4)))
        }
    }
    impl From<U256> for Udec256 {
        fn from(value: U256) -> Self {
            Self::raw(Uint::new(value))
        }
    }
    impl From<Uint<U256>> for Udec256 {
        fn from(value: Uint<U256>) -> Self {
            Self::raw(value)
        }
    }
    impl From<Udec128> for Udec256 {
        fn from(value: Udec128) -> Self {
            Self::from_decimal(value)
        }
    }
    impl From<Uint<<Udec128 as Inner>::U>> for Udec256 {
        fn from(value: Uint<<Udec128 as Inner>::U>) -> Self {
            Self::raw(value.into())
        }
    }
    impl From<<Udec128 as Inner>::U> for Udec256 {
        fn from(value: <Udec128 as Inner>::U) -> Self {
            Self::raw(value.into())
        }
    }
    impl TryFrom<Udec256> for Udec128 {
        type Error = MathError;
        fn try_from(value: Udec256) -> MathResult<Udec128> {
            <Udec128>::try_from_decimal(value)
        }
    }
    impl TryFrom<Udec256> for Uint<<Udec128 as Inner>::U> {
        type Error = MathError;
        fn try_from(value: Udec256) -> MathResult<Uint<<Udec128 as Inner>::U>> {
            value.0.try_into().map(Self)
        }
    }
    impl TryFrom<Udec256> for <Udec128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Udec256) -> MathResult<<Udec128 as Inner>::U> {
            value.0.try_into()
        }
    }
    ///128-bit signed fixed-point number with 18 decimal places.
    pub type Dec128 = Udec<i128>;
    impl Dec128 {
        /// Create a new [`Udec`] adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let decimal = Udec128::new(100);
        /// assert_eq!(decimal, Udec128::from_str("100.0").unwrap());
        /// ```
        pub const fn new(x: i128) -> Self {
            Self(Int128::new(x * 10_i128.pow(Self::DECIMAL_PLACES)))
        }
        pub const fn new_percent(x: i128) -> Self {
            Self(Int128::new(x * 10_i128.pow(Self::DECIMAL_PLACES - 2)))
        }
        pub const fn new_permille(x: i128) -> Self {
            Self(Int128::new(x * 10_i128.pow(Self::DECIMAL_PLACES - 3)))
        }
        pub const fn new_bps(x: i128) -> Self {
            Self(Int128::new(x * 10_i128.pow(Self::DECIMAL_PLACES - 4)))
        }
    }
    impl From<i128> for Dec128 {
        fn from(value: i128) -> Self {
            Self::raw(Uint::new(value))
        }
    }
    impl From<Uint<i128>> for Dec128 {
        fn from(value: Uint<i128>) -> Self {
            Self::raw(value)
        }
    }
    ///128-bit signed fixed-point number with 18 decimal places.
    pub type Dec256 = Udec<I256>;
    impl Dec256 {
        /// Create a new [`Udec`] adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let decimal = Udec128::new(100);
        /// assert_eq!(decimal, Udec128::from_str("100.0").unwrap());
        /// ```
        pub const fn new(x: i128) -> Self {
            Self(Int256::new_from_i128(x * 10_i128.pow(Self::DECIMAL_PLACES)))
        }
        pub const fn new_percent(x: i128) -> Self {
            Self(Int256::new_from_i128(x * 10_i128.pow(Self::DECIMAL_PLACES - 2)))
        }
        pub const fn new_permille(x: i128) -> Self {
            Self(Int256::new_from_i128(x * 10_i128.pow(Self::DECIMAL_PLACES - 3)))
        }
        pub const fn new_bps(x: i128) -> Self {
            Self(Int256::new_from_i128(x * 10_i128.pow(Self::DECIMAL_PLACES - 4)))
        }
    }
    impl From<I256> for Dec256 {
        fn from(value: I256) -> Self {
            Self::raw(Uint::new(value))
        }
    }
    impl From<Uint<I256>> for Dec256 {
        fn from(value: Uint<I256>) -> Self {
            Self::raw(value)
        }
    }
    ///128-bit unsigned fixed-point number with 18 decimal places.
    pub type Udec64_24 = Udec<u64>;
    impl Udec64_24 {
        /// Create a new [`Udec`] adding decimal places.
        ///
        /// ```rust
        /// use {
        ///     grug_math::{Udec128, Uint128},
        ///     std::str::FromStr,
        /// };
        ///
        /// let decimal = Udec128::new(100);
        /// assert_eq!(decimal, Udec128::from_str("100.0").unwrap());
        /// ```
        pub const fn new(x: u128) -> Self {
            Self(Uint64::new(x * 10_u128.pow(Self::DECIMAL_PLACES)))
        }
        pub const fn new_percent(x: u128) -> Self {
            Self(Uint64::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 2)))
        }
        pub const fn new_permille(x: u128) -> Self {
            Self(Uint64::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 3)))
        }
        pub const fn new_bps(x: u128) -> Self {
            Self(Uint64::new(x * 10_u128.pow(Self::DECIMAL_PLACES - 4)))
        }
    }
    impl From<u64> for Udec64_24 {
        fn from(value: u64) -> Self {
            Self::raw(Uint::new(value))
        }
    }
    impl From<Uint<u64>> for Udec64_24 {
        fn from(value: Uint<u64>) -> Self {
            Self::raw(value)
        }
    }
}
mod uint {
    use {
        crate::{
            utils::{bytes_to_digits, grow_le_int, grow_le_uint},
            Inner, Integer, MathError, MathResult, NextNumber, Number,
        },
        bnum::types::{I256, I512, U256, U512},
        borsh::{BorshDeserialize, BorshSerialize},
        serde::{de, ser},
        std::{
            fmt::{self, Display},
            marker::PhantomData,
            ops::{
                Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Rem, RemAssign, Shl,
                ShlAssign, Shr, ShrAssign, Sub, SubAssign,
            },
            str::FromStr,
        },
    };
    pub struct Uint<U>(pub(crate) U);
    impl<U> borsh::ser::BorshSerialize for Uint<U>
    where
        U: borsh::ser::BorshSerialize,
    {
        fn serialize<__W: borsh::io::Write>(
            &self,
            writer: &mut __W,
        ) -> ::core::result::Result<(), borsh::io::Error> {
            borsh::BorshSerialize::serialize(&self.0, writer)?;
            Ok(())
        }
    }
    impl<U> borsh::de::BorshDeserialize for Uint<U>
    where
        U: borsh::de::BorshDeserialize,
    {
        fn deserialize_reader<__R: borsh::io::Read>(
            reader: &mut __R,
        ) -> ::core::result::Result<Self, borsh::io::Error> {
            Ok(Self(borsh::BorshDeserialize::deserialize_reader(reader)?))
        }
    }
    #[automatically_derived]
    impl<U: ::core::default::Default> ::core::default::Default for Uint<U> {
        #[inline]
        fn default() -> Uint<U> {
            Uint(::core::default::Default::default())
        }
    }
    #[automatically_derived]
    impl<U: ::core::fmt::Debug> ::core::fmt::Debug for Uint<U> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Uint", &&self.0)
        }
    }
    #[automatically_derived]
    impl<U: ::core::clone::Clone> ::core::clone::Clone for Uint<U> {
        #[inline]
        fn clone(&self) -> Uint<U> {
            Uint(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<U: ::core::marker::Copy> ::core::marker::Copy for Uint<U> {}
    #[automatically_derived]
    impl<U> ::core::marker::StructuralPartialEq for Uint<U> {}
    #[automatically_derived]
    impl<U: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Uint<U> {
        #[inline]
        fn eq(&self, other: &Uint<U>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::Eq> ::core::cmp::Eq for Uint<U> {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<U>;
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Uint<U> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint<U>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<U: ::core::cmp::Ord> ::core::cmp::Ord for Uint<U> {
        #[inline]
        fn cmp(&self, other: &Uint<U>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    impl<U> Uint<U> {
        pub const fn new(value: U) -> Self {
            Self(value)
        }
    }
    impl<U> Uint<U>
    where
        U: Copy,
    {
        pub const fn number(&self) -> U {
            self.0
        }
        pub const fn number_ref(&self) -> &U {
            &self.0
        }
    }
    impl<U> Uint<U>
    where
        Uint<U>: NextNumber,
        <Uint<U> as NextNumber>::Next: Number,
    {
        pub fn checked_full_mul(
            self,
            rhs: impl Into<Self>,
        ) -> MathResult<<Uint<U> as NextNumber>::Next> {
            let s = self.into_next();
            let r = rhs.into().into_next();
            s.checked_mul(r)
        }
    }
    impl<U> FromStr for Uint<U>
    where
        U: FromStr,
        <U as FromStr>::Err: ToString,
    {
        type Err = MathError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            U::from_str(s)
                .map(Self)
                .map_err(|err| MathError::parse_number::<Self, _, _>(s, err))
        }
    }
    impl<U> fmt::Display for Uint<U>
    where
        U: Display,
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(format_args!("{0}", self.0))
        }
    }
    impl<U> ser::Serialize for Uint<U>
    where
        Uint<U>: Display,
    {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ser::Serializer,
        {
            serializer.serialize_str(&self.to_string())
        }
    }
    impl<'de, U> de::Deserialize<'de> for Uint<U>
    where
        Uint<U>: FromStr,
        <Uint<U> as FromStr>::Err: Display,
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            deserializer.deserialize_str(UintVisitor::<U>::new())
        }
    }
    struct UintVisitor<U> {
        _marker: PhantomData<U>,
    }
    impl<U> UintVisitor<U> {
        pub fn new() -> Self {
            Self { _marker: PhantomData }
        }
    }
    impl<'de, U> de::Visitor<'de> for UintVisitor<U>
    where
        Uint<U>: FromStr,
        <Uint<U> as FromStr>::Err: Display,
    {
        type Value = Uint<U>;
        fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.write_str("a string-encoded unsigned integer")
        }
        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Uint::<U>::from_str(v).map_err(E::custom)
        }
    }
    impl<U> Neg for Uint<U>
    where
        U: Neg<Output = U>,
    {
        type Output = Self;
        fn neg(self) -> Self::Output {
            Self(-self.0)
        }
    }
    impl<U> Add for Uint<U>
    where
        U: Number,
    {
        type Output = Self;
        fn add(self, rhs: Self) -> Self::Output {
            self.checked_add(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Sub for Uint<U>
    where
        U: Number,
    {
        type Output = Self;
        fn sub(self, rhs: Self) -> Self::Output {
            self.checked_sub(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Mul for Uint<U>
    where
        U: Number,
    {
        type Output = Self;
        fn mul(self, rhs: Self) -> Self::Output {
            self.checked_mul(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Div for Uint<U>
    where
        U: Number,
    {
        type Output = Self;
        fn div(self, rhs: Self) -> Self::Output {
            self.checked_div(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Rem for Uint<U>
    where
        U: Number,
    {
        type Output = Self;
        fn rem(self, rhs: Self) -> Self::Output {
            self.checked_rem(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Shl<u32> for Uint<U>
    where
        U: Integer,
    {
        type Output = Self;
        fn shl(self, rhs: u32) -> Self::Output {
            self.checked_shl(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> Shr<u32> for Uint<U>
    where
        U: Integer,
    {
        type Output = Self;
        fn shr(self, rhs: u32) -> Self::Output {
            self.checked_shr(rhs)
                .unwrap_or_else(|err| {
                    ::core::panicking::panic_fmt(format_args!("{0}", err));
                })
        }
    }
    impl<U> AddAssign for Uint<U>
    where
        U: Number + Copy,
    {
        fn add_assign(&mut self, rhs: Self) {
            *self = *self + rhs;
        }
    }
    impl<U> SubAssign for Uint<U>
    where
        U: Number + Copy,
    {
        fn sub_assign(&mut self, rhs: Self) {
            *self = *self - rhs;
        }
    }
    impl<U> MulAssign for Uint<U>
    where
        U: Number + Copy,
    {
        fn mul_assign(&mut self, rhs: Self) {
            *self = *self * rhs;
        }
    }
    impl<U> DivAssign for Uint<U>
    where
        U: Number + Copy,
    {
        fn div_assign(&mut self, rhs: Self) {
            *self = *self / rhs;
        }
    }
    impl<U> RemAssign for Uint<U>
    where
        U: Number + Copy,
    {
        fn rem_assign(&mut self, rhs: Self) {
            *self = *self % rhs;
        }
    }
    impl<U> ShlAssign<u32> for Uint<U>
    where
        U: Integer + Copy,
    {
        fn shl_assign(&mut self, rhs: u32) {
            *self = *self << rhs;
        }
    }
    impl<U> ShrAssign<u32> for Uint<U>
    where
        U: Integer + Copy,
    {
        fn shr_assign(&mut self, rhs: u32) {
            *self = *self >> rhs;
        }
    }
    ///64-bit unsigned integer.
    pub type Uint64 = Uint<u64>;
    impl From<u32> for Uint64 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint64> for u32 {
        type Error = MathError;
        fn try_from(value: Uint64) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Uint64 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint64> for u16 {
        type Error = MathError;
        fn try_from(value: Uint64) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Uint64 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint64> for u8 {
        type Error = MathError;
        fn try_from(value: Uint64) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<u64> for Uint64 {
        fn from(value: u64) -> Self {
            Self::new(value)
        }
    }
    impl From<Uint64> for u64 {
        fn from(value: Uint64) -> Self {
            value.number()
        }
    }
    ///128-bit unsigned integer.
    pub type Uint128 = Uint<u128>;
    impl From<Uint64> for Uint128 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Uint128 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint128> for Uint64 {
        type Error = MathError;
        fn try_from(value: Uint128) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Uint128> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint128) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<u32> for Uint128 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint128> for u32 {
        type Error = MathError;
        fn try_from(value: Uint128) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Uint128 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint128> for u16 {
        type Error = MathError;
        fn try_from(value: Uint128) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Uint128 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint128> for u8 {
        type Error = MathError;
        fn try_from(value: Uint128) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<u128> for Uint128 {
        fn from(value: u128) -> Self {
            Self::new(value)
        }
    }
    impl From<Uint128> for u128 {
        fn from(value: Uint128) -> Self {
            value.number()
        }
    }
    ///256-bit unsigned integer.
    pub type Uint256 = Uint<U256>;
    impl From<Uint64> for Uint256 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Uint256 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint256> for Uint64 {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Uint256> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<Uint128> for Uint256 {
        fn from(value: Uint128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint128 as Inner>::U> for Uint256 {
        fn from(value: <Uint128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint256> for Uint128 {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<Uint128> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl TryFrom<Uint256> for <Uint128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<<Uint128 as Inner>::U> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl From<u32> for Uint256 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint256> for u32 {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Uint256 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint256> for u16 {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Uint256 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint256> for u8 {
        type Error = MathError;
        fn try_from(value: Uint256) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<U256> for Uint256 {
        fn from(value: U256) -> Self {
            Self::new(value)
        }
    }
    impl From<Uint256> for U256 {
        fn from(value: Uint256) -> Self {
            value.number()
        }
    }
    ///512-bit unsigned integer.
    pub type Uint512 = Uint<U512>;
    impl From<Uint256> for Uint512 {
        fn from(value: Uint256) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint256 as Inner>::U> for Uint512 {
        fn from(value: <Uint256 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for Uint256 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<Uint256> {
            <Uint256 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint256>(value))
        }
    }
    impl TryFrom<Uint512> for <Uint256 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<<Uint256 as Inner>::U> {
            <Uint256 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint256>(value))
        }
    }
    impl From<Uint64> for Uint512 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Uint512 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for Uint64 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Uint512> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<Uint128> for Uint512 {
        fn from(value: Uint128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint128 as Inner>::U> for Uint512 {
        fn from(value: <Uint128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for Uint128 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<Uint128> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl TryFrom<Uint512> for <Uint128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<<Uint128 as Inner>::U> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl From<u32> for Uint512 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for u32 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Uint512 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for u16 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Uint512 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Uint512> for u8 {
        type Error = MathError;
        fn try_from(value: Uint512) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<U512> for Uint512 {
        fn from(value: U512) -> Self {
            Self::new(value)
        }
    }
    impl From<Uint512> for U512 {
        fn from(value: Uint512) -> Self {
            value.number()
        }
    }
    ///64-bit signed integer.
    pub type Int64 = Uint<i64>;
    impl From<u32> for Int64 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int64> for u32 {
        type Error = MathError;
        fn try_from(value: Int64) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Int64 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int64> for u16 {
        type Error = MathError;
        fn try_from(value: Int64) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Int64 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int64> for u8 {
        type Error = MathError;
        fn try_from(value: Int64) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<i64> for Int64 {
        fn from(value: i64) -> Self {
            Self::new(value)
        }
    }
    impl From<Int64> for i64 {
        fn from(value: Int64) -> Self {
            value.number()
        }
    }
    ///128-bit signed integer.
    pub type Int128 = Uint<i128>;
    impl From<Int64> for Int128 {
        fn from(value: Int64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Int64 as Inner>::U> for Int128 {
        fn from(value: <Int64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int128> for Int64 {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<Int64> {
            <Int64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl TryFrom<Int128> for <Int64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<<Int64 as Inner>::U> {
            <Int64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl From<Uint64> for Int128 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Int128 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int128> for Uint64 {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Int128> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<u32> for Int128 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int128> for u32 {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Int128 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int128> for u16 {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Int128 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int128> for u8 {
        type Error = MathError;
        fn try_from(value: Int128) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<i128> for Int128 {
        fn from(value: i128) -> Self {
            Self::new(value)
        }
    }
    impl From<Int128> for i128 {
        fn from(value: Int128) -> Self {
            value.number()
        }
    }
    ///256-bit signed integer.
    pub type Int256 = Uint<I256>;
    impl From<Int128> for Int256 {
        fn from(value: Int128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Int128 as Inner>::U> for Int256 {
        fn from(value: <Int128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for Int128 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<Int128> {
            <Int128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Int128>(value))
        }
    }
    impl TryFrom<Int256> for <Int128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<<Int128 as Inner>::U> {
            <Int128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Int128>(value))
        }
    }
    impl From<Int64> for Int256 {
        fn from(value: Int64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Int64 as Inner>::U> for Int256 {
        fn from(value: <Int64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for Int64 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<Int64> {
            <Int64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl TryFrom<Int256> for <Int64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<<Int64 as Inner>::U> {
            <Int64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl From<Uint128> for Int256 {
        fn from(value: Uint128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint128 as Inner>::U> for Int256 {
        fn from(value: <Uint128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for Uint128 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<Uint128> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl TryFrom<Int256> for <Uint128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<<Uint128 as Inner>::U> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl From<Uint64> for Int256 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Int256 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for Uint64 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Int256> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<u32> for Int256 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for u32 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Int256 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for u16 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Int256 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int256> for u8 {
        type Error = MathError;
        fn try_from(value: Int256) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<I256> for Int256 {
        fn from(value: I256) -> Self {
            Self::new(value)
        }
    }
    impl From<Int256> for I256 {
        fn from(value: Int256) -> Self {
            value.number()
        }
    }
    ///512-bit signed integer.
    pub type Int512 = Uint<I512>;
    impl From<Int128> for Int512 {
        fn from(value: Int128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Int128 as Inner>::U> for Int512 {
        fn from(value: <Int128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for Int128 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<Int128> {
            <Int128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Int128>(value))
        }
    }
    impl TryFrom<Int512> for <Int128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<<Int128 as Inner>::U> {
            <Int128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Int128>(value))
        }
    }
    impl From<Int64> for Int512 {
        fn from(value: Int64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Int64 as Inner>::U> for Int512 {
        fn from(value: <Int64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for Int64 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<Int64> {
            <Int64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl TryFrom<Int512> for <Int64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<<Int64 as Inner>::U> {
            <Int64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Int64>(value))
        }
    }
    impl From<Uint128> for Int512 {
        fn from(value: Uint128) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint128 as Inner>::U> for Int512 {
        fn from(value: <Uint128 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for Uint128 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<Uint128> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl TryFrom<Int512> for <Uint128 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<<Uint128 as Inner>::U> {
            <Uint128 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint128>(value))
        }
    }
    impl From<Uint64> for Int512 {
        fn from(value: Uint64) -> Self {
            Self(value.number().into())
        }
    }
    impl From<<Uint64 as Inner>::U> for Int512 {
        fn from(value: <Uint64 as Inner>::U) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for Uint64 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<Uint64> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map(Self)
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl TryFrom<Int512> for <Uint64 as Inner>::U {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<<Uint64 as Inner>::U> {
            <Uint64 as Inner>::U::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, Uint64>(value))
        }
    }
    impl From<u32> for Int512 {
        fn from(value: u32) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for u32 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<u32> {
            <u32>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u32>(value))
        }
    }
    impl From<u16> for Int512 {
        fn from(value: u16) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for u16 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<u16> {
            <u16>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u16>(value))
        }
    }
    impl From<u8> for Int512 {
        fn from(value: u8) -> Self {
            Self(value.into())
        }
    }
    impl TryFrom<Int512> for u8 {
        type Error = MathError;
        fn try_from(value: Int512) -> MathResult<u8> {
            <u8>::try_from(value.number())
                .map_err(|_| MathError::overflow_conversion::<_, u8>(value))
        }
    }
    impl From<I512> for Int512 {
        fn from(value: I512) -> Self {
            Self::new(value)
        }
    }
    impl From<Int512> for I512 {
        fn from(value: Int512) -> Self {
            value.number()
        }
    }
    impl Uint256 {
        pub const fn new_from_u128(value: u128) -> Self {
            let grown_bytes = grow_le_uint::<16, 32>(value.to_le_bytes());
            let digits = bytes_to_digits(grown_bytes);
            Self(U256::from_digits(digits))
        }
    }
    impl Uint512 {
        pub const fn new_from_u128(value: u128) -> Self {
            let grown_bytes = grow_le_uint::<16, 64>(value.to_le_bytes());
            let digits = bytes_to_digits(grown_bytes);
            Self(U512::from_digits(digits))
        }
    }
    impl Int256 {
        pub const fn new_from_i128(value: i128) -> Self {
            let grown_bytes = grow_le_int::<16, 32>(value.to_le_bytes());
            let digits = bytes_to_digits(grown_bytes);
            Self(I256::from_bits(U256::from_digits(digits)))
        }
    }
    impl Int512 {
        pub const fn new_from_i128(value: i128) -> Self {
            let grown_bytes = grow_le_int::<16, 64>(value.to_le_bytes());
            let digits = bytes_to_digits(grown_bytes);
            Self(I512::from_bits(U512::from_digits(digits)))
        }
    }
}
mod utils {
    #[allow(dead_code)]
    pub(crate) const fn grow_be_int<const INPUT_SIZE: usize, const OUTPUT_SIZE: usize>(
        input: [u8; INPUT_SIZE],
    ) -> [u8; OUTPUT_SIZE] {
        if true {
            if !(INPUT_SIZE <= OUTPUT_SIZE) {
                ::core::panicking::panic("assertion failed: INPUT_SIZE <= OUTPUT_SIZE")
            }
        }
        let mut output = if input[0] & 0b10000000 != 0 {
            [0b11111111u8; OUTPUT_SIZE]
        } else {
            [0u8; OUTPUT_SIZE]
        };
        let mut i = 0;
        while i < INPUT_SIZE {
            output[OUTPUT_SIZE - INPUT_SIZE + i] = input[i];
            i += 1;
        }
        output
    }
    #[allow(dead_code)]
    pub(crate) const fn grow_le_int<const INPUT_SIZE: usize, const OUTPUT_SIZE: usize>(
        input: [u8; INPUT_SIZE],
    ) -> [u8; OUTPUT_SIZE] {
        if true {
            if !(INPUT_SIZE <= OUTPUT_SIZE) {
                ::core::panicking::panic("assertion failed: INPUT_SIZE <= OUTPUT_SIZE")
            }
        }
        let mut output = if input[INPUT_SIZE - 1] & 0b10000000 != 0 {
            [0b11111111u8; OUTPUT_SIZE]
        } else {
            [0u8; OUTPUT_SIZE]
        };
        let mut i = 0;
        while i < INPUT_SIZE {
            output[i] = input[i];
            i += 1;
        }
        output
    }
    pub(crate) const fn grow_be_uint<const INPUT_SIZE: usize, const OUTPUT_SIZE: usize>(
        input: [u8; INPUT_SIZE],
    ) -> [u8; OUTPUT_SIZE] {
        if true {
            if !(INPUT_SIZE <= OUTPUT_SIZE) {
                ::core::panicking::panic("assertion failed: INPUT_SIZE <= OUTPUT_SIZE")
            }
        }
        let mut output = [0u8; OUTPUT_SIZE];
        let mut i = 0;
        while i < INPUT_SIZE {
            output[OUTPUT_SIZE - INPUT_SIZE + i] = input[i];
            i += 1;
        }
        output
    }
    pub(crate) const fn grow_le_uint<const INPUT_SIZE: usize, const OUTPUT_SIZE: usize>(
        input: [u8; INPUT_SIZE],
    ) -> [u8; OUTPUT_SIZE] {
        if true {
            if !(INPUT_SIZE <= OUTPUT_SIZE) {
                ::core::panicking::panic("assertion failed: INPUT_SIZE <= OUTPUT_SIZE")
            }
        }
        let mut output = [0u8; OUTPUT_SIZE];
        let mut i = 0;
        while i < INPUT_SIZE {
            output[i] = input[i];
            i += 1;
        }
        output
    }
    pub(crate) const fn bytes_to_digits<const S: usize, const OUT_SIZE: usize>(
        data: [u8; S],
    ) -> [u64; OUT_SIZE] {
        let mut result = [0u64; OUT_SIZE];
        let mut i = 0;
        while i < OUT_SIZE {
            result[i] = (data[i * 8] as u64) | ((data[i * 8 + 1] as u64) << 8)
                | ((data[i * 8 + 2] as u64) << 16) | ((data[i * 8 + 3] as u64) << 24)
                | ((data[i * 8 + 4] as u64) << 32) | ((data[i * 8 + 5] as u64) << 40)
                | ((data[i * 8 + 6] as u64) << 48) | ((data[i * 8 + 7] as u64) << 56);
            i += 1;
        }
        result
    }
}
pub use {
    bytable::*, decimal::*, error::*, fixed_point::*, fraction::*, inner::*, integer::*,
    is_zero::*, multiply_fraction::*, multiply_ratio::*, next::*, number::*,
    number_const::*, sign::*, udec::*, uint::*,
};
